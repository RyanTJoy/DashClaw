/**
 * Proof artifact generator
 * Converts test results into compliance-ready reports
 * Absorbed from dashclaw-guardrails/packages/guardrailgen-js/src/report.js
 */

/**
 * Generate markdown proof report
 * @param {object} policyDoc - Policy document
 * @param {object} testResults - Test results (optional)
 * @returns {string} Markdown report
 */
export function generateMarkdownReport(policyDoc, testResults = null) {
  const { project, policies } = policyDoc;
  const timestamp = new Date().toISOString();

  let md = `# Guardrails Proof Report\n\n**Project:** ${project || 'N/A'}  \n**Generated:** ${timestamp}\n\n---\n\n## Summary\n\n- **Total Policies:** ${policies.length}\n- **Total Test Cases:** ${countTests(policies)}\n`;

  if (testResults) {
    md += `- **Tests Passed:** ${testResults.numPassedTests || 0}/${testResults.numTotalTests || 0}\n- **Status:** ${testResults.success ? 'PASS' : 'FAIL'}\n`;
  }

  md += `\n---\n\n## Policies\n\n`;

  for (const policy of policies) {
    md += generatePolicySection(policy);
  }

  md += `\n---\n\n## Attestation\n\nThis report was auto-generated by DashClaw guardrails and proves that the following guardrails are:\n1. Defined in code (policy-as-code)\n2. Tested with executable test cases\n3. Enforced by deterministic evaluation logic\n\n`;

  return md;
}

function countTests(policies) {
  return policies.reduce((sum, p) => sum + (p.tests?.length || 0), 0);
}

function generatePolicySection(policy) {
  const { id, description, applies_to, rule, tests } = policy;

  let section = `### Policy: \`${id}\`\n\n**Description:** ${description}\n\n**Applies to:**\n${applies_to.tools.map(t => `- \`${t}\``).join('\n')}\n\n**Rule:**\n`;

  if (rule.block) {
    section += `- **Action:** BLOCK\n`;
    if (rule.allowlist && rule.allowlist.length > 0) {
      section += `- **Allowlist:** ${rule.allowlist.map(a => `\`${a}\``).join(', ')}\n`;
    }
  } else if (rule.require === 'approval') {
    section += `- **Action:** REQUIRE APPROVAL\n`;
  }

  section += `\n**Test Coverage:** ${tests?.length || 0} test case(s)\n`;

  if (tests && tests.length > 0) {
    section += `\n**Test Cases:**\n`;
    for (const test of tests) {
      section += `- ${test.name}: expects \`allowed=${test.expect.allowed}\`\n`;
    }
  }

  section += `\n`;
  return section;
}

/**
 * Generate JSON proof report (machine-readable)
 */
export function generateJsonReport(policyDoc, testResults = null) {
  const { project, policies } = policyDoc;

  return JSON.stringify({
    project,
    generated_at: new Date().toISOString(),
    summary: {
      total_policies: policies.length,
      total_tests: countTests(policies),
      test_results: testResults ? {
        passed: testResults.numPassedTests || 0,
        total: testResults.numTotalTests || 0,
        success: testResults.success
      } : null
    },
    policies: policies.map(p => ({
      id: p.id,
      description: p.description,
      applies_to: p.applies_to,
      rule: p.rule,
      test_count: p.tests?.length || 0
    }))
  }, null, 2);
}
